# An Ontological Architecture for Principled and Automated System of Systems Composition

# Authors:

## Abdessalam Elhabbash, 

![Image](./image9.jpg)

## Vatsala Nundloll, 

## Yehia Elkhatib,
![Image](./image8.jpg) 

## Gordon Blair, 

## Vicent Sanz Marco

# Confrence Name
## ICSE 2020 Program
***

[Confrence Link](https://2020.icse-conferences.org/program/program-icse-2020)

>Venue:Tue 30 Jun 2020 14:00 - 14:05 at SEAMS - Session 3: Composition, Control and Trustworthiness 
>>Chair(s): Danny Weyns


[Preprint Link](https://yelkhatib.github.io/papers/Elhabbash2020Ontological.pdf)

[Medial Link](https://youtu.be/jp5djzHGtiQ)

# Abstract:

A dsitributed system is continuously evolved in changes according to enviroment so we adapt system of systems to understand software.This paper presents a conceptual methodology for selecting existing systems to form candidate systems of systems (SoS) and selecting the preferred candidate SoS to provide a new capability. This methodology begins with SoS acquisition and mission requirements and selects the preferred SoS in six steps. Decision factors used for this purpose are selected based on their importance in providing and sustaining the required SoS capability. A new index of priority is introduced and utilized in this methodology to compare candidate systems, in terms of their assigned mission priority, with respect to the SoS mission priority, as well as their contribution to the SoS mission.  In the last decades, the use of ontologies in information systems has become more and more popular in various fields, such as web technologies, database integration, multi agent systems, natural language processing, etc. Artificial intelligent researchers have initially borrowed the word “ontology” from Philosophy, then the word spread in many scientific domain and ontologies are now used in several developments.

# Introduction:
Computer system are evovled in the basic pictures of connected PCS to inter connected PCS of heterogenous system. .Each of these systems contains a set of heterogeneous components that implement diverse functions communicating using different protocols.Further more,these various systems often need to interact and collaborate to achieve their goals.For example,isolated rescue teams need to opportunistically compose and access each others services(e.g.,datalook-up)to exchange information; deployed environmental IoT systems process their data on a micro cloud in their vicinity and off load certain processing to the cloud when needed; etc. In this sense, larger systems are constructed through the interaction of smaller ones,a practice known as System of Systems (SoS) composition.Heterogenity and scale pose significant challenges to SoS construction. Developers need knowldege to construct SoS. A number sub systems combined to make a system of system it is a complex system. SoSs are typically deployed in environments where context changes.This is where the need arises to veerfromastrict work flow path that has been defined at design time,and form a more complex system in order to maintain the intended abstract behavior or to be able to provide new behavior that is only possible through uniting with other systems in the new context.Such examples include disaster recovery,adaptive IoT applications,volunteer and crowd computing, military defense operations, and other forms of cyber physical systems.Further more,the development of SoS is dynamic in nature.This is grounded in the knowledge that systems are persistent and long-living. As such, their objectives and functionalities evolve over time as they are constantly added,modified,or removed at different time scales.This might also predicate changes in architectural and functional dependencies. An example of ontology is when a physicist establishes different categories to divide existing things into in order to better understand those things and how they fit together in the broader world. ... Whereas the World Wide Web links Web pages together, the Semantic Web links the data on the Web that are related. In order to achieve this objective,there is a need for semantics to comprehensively describe the system structure,capturing the information required for dynamically composing systems such as those relating to communication(e.g.,unique identifiers),service discovery,quality of service,physical properties(e.g.,powerlevel and location),environmental properties,etc.We refer to this comprehensive structure description of a system as a holon. A holon is constantly modified to reflect the system structure and to contain any new or modified information,and then published to aid discovery and reasoning about composition.When holons compose,they form a new holon that represents the SoS.This newlyc onstructed holon will now have its own specification,which is published so that thee system can further compose with other SoSs and soon. The service composition supported by SOA is mainly functionality based composition.How ever,SoS composition is wider than this,as it also requires knowledge about system properties and context to reason about the composition.Second,services in SOA are assumed to be published in a repository that an orchestrator can consult to select services from.This assumption is not valid in the general SoS context which is fully distributed.Third,SOA-based SoS developers are expected to know alot about individual systems,or invest significant time learning them.   Developers are required to acquire knowledge about the APIs and properties of the elementary systems they need to compose.Then, they need to leverage that knowledge to design and implement the SoS,and finally deploy it.This requires the developer to focus on the elementary systems instead of the whole SoS.

# Problem Space and Related Work:
This paper presents an approach to system-of-systems engineering for product development with the use of ontology. A proposed method for building as well as using ontology to generate and explore system-of-systems design spaces based on identified system-of-system needs is presented. The method is largely built to cover the first levels of related work, where a process for system of systems in the context of product development is introduced. Within this work, it is shown that scenarios for a system-of-systems can be used to identify needs and subsequently the system-of-systems capabilities that fulfils them. The allocation of capabilities to possible constituent systems is used to show the available design space. The proposed method of this paper therefore addresses these initial challenges and provides a framework for approaching the system-of-systems design space creation using ontology. A case study is used to test the method on a fictitious search and rescue scenario based on available resources and information from the Swedish Maritime Administration. The case study shows that a representation of a system-of-systems scenario can be created in an ontology using the method. The ontology provides a representation of the involved entities from the fictitious scenario and their existing relationships. Defined ontology classes containing conditions are used to represent the identified needs for the system-of-systems. The invocation of a description logic reasoner is subsequently used to classify and create an inferred ontology where the available system-of-systems solutions are represented as sub-classes and individuals of the defined classes representing the needs. Finally, several classes representing different possible system-of-systems needs are used to explore the available design space and to identify the most persistent solutions of the case study.

# RESEARCH STRATEGY:

Based on the above, our ultimate goal is to shift the developers’ focus from learning the internals of elementary systems to thinking at the level of the SoS. As shown in Fig. 1, holons allow developers to focus on defining high-level workflows of the SoS. The elementary systems need to autonomously discover each other and compose to serve the requests.The achievement of this goal requires (1) a comprehensive description of the atomic systems (their services, properties, and context) that enable autonomous composition between systems;

and (2) an architecture the exploits such descriptions and supports SoS composition and adaptation.

# 4 THE HOLONIC LIFE CYCLE: 
A holon starts as an atomic one then might evolve to being composite. An atomic holon represents a single system that provides one or more functionalities.A composite holon includes functionalities provided by a number of systems interacting with eachother either directly or through others. In order for holons to compose, atomic holons need to be comprehensively specified by the system developer.After that,the system will be dynamically constructed as the holons iterate in their lifecycle.The four stages of a holon’s life cycle:

## Specification:
A system developer uses an ontology to create the holon from a number of elementary descriptions.This includes a holon identifier,the physical properties of the system(e.g.,power level),quality of service(e.g.,availability and reliability),environmental properties(e.g., location),policies(e.g., routingprotocol), services (e.g., sensing temperature), among others. All these are specified using our ontological model.

## Dissemination:
A created holon disseminates its specification so it can be discovered. Different dissemination strategies can be adopted: push, pull, and lookup. In the push strategy, the holon periodically broadcasts its latest description. In contrast, a pull strategy uses heartbeat signals; i.e., the holon periodically sends ‘Hello’messages to establish interaction with other systems,which could then request the full holon description.This strategy reduces overhead,so isuseful in energy-constrained environments.Inthe lookup strategy,the holon registers its description with a registry that can be consulted by other systems to obtain the holon.This strategy is to be used when infra structure assistance is guaranteed. We adopt the push strategy for the scope of this paper.

## Compilation:
This aims at understanding other holons and their functionalities.This is achieved by parsing received descriptions (in the form of XML representations), and identifying the functionalities contained within,and how they interact with that of the received holon.Compiling these functionalities into one holon representing a new SoS comprising of the interacting holons. 

## Modification

Holons can change at run time due to a changein the physical system(e.g.,update of a service)or due to a structural change(e.g.,composition to a new holon).In either case,the holon description will be modified to reflect the change.Upon obtaining a modified version of a holon,the receiving holon will re compile its own holon and disseminate it.This will convey the changes to the whole SoS.

# The Ontological Model:
Ontology model allows structure information as well as to raises the effectiveness of search. Research describes the development of ontology models for engineering knowledge in Internet portal and modeling system for the classification and recognition of marine objects. For a holon to be able to compose with another holon at run time,it needs to advertise its own definition in a systematic way that can be easily understood by the receiving holon.For this,the definition needs to embody the different concepts surrounding the holon, triggering the need for an appropriate structure to representit. In this respect,an ontology seems to be  the best technique to capture the definition and behavior of a holon.Anontology is a formal and explicit specification of a shared conceptualization. It models some aspect of the world (called a domain), and provides a simplified view of certain phenomena in this domain. The description of the domain is based on a vocabulary that explicitly defines its concepts, properties,relations,functions,and constraints. 

For our purposes, the ontology will be used by a holon to advertise its services,the types of input parameters requiredforsaid services,and the types of outputs they produce,if any.Further more, the ontology isused to identify the physical properties of the holon such as the power level(infinite/finite),location,operating system, mobility,etc. Whilst an entirely new ontology can be developed from scratch, we deemed it more constructive to look at existing ontologies and extend suitable ones, i.e., the ones that contain the semantics required to describe holons,if and where necessary. In order to identify the most appropriate ontology to represent holons,we looked at different sensor and observation ontologies.We started with those surveyed by th eW3C Semantic Sensor Network (SSN) In cubator Group,and continued with our own study of others.  Based on this investigation,the ontologies that we found suitable for extension are(in chronological order):CoDAMOS,Swamo, A3ME, and Ontonym. We concluded to use CoDAMOS  due to its inherent predis position for modification, making it easily extensible for defining context-aware computing infra structures varying from small embedded devices to high-end service platforms. Further more,CoDAMOS’sconcepts closely match the kind of definitions we want to create for a holon. For example, the Service concept- i.e., having a service pro file-can be used to define the types of services provided or required by a holon.Note,however, that this doesnot imply that the other short listed ontologies cannot be used.Indeed,A3ME (to pick just one other ontology)could be merged with CoDAMOS to describe further concepts related to holonic design;for instance,the API Public CoDAMOS concept can be further described as Global Address,Local Address,or Other Address usingtheAddress concept of A3ME. For this paper,we use CoDAMOS as the basis ontology wit hthe aim of answering our research questions.

# Extensions:
Extensions shows the type of file that wich type of file is and which language is related this file extension gives us look of file.

 # Application:
 For demonstration, we show how two holons can be composed using their underlying description. As such,the starting pointis where each holon defines it self using the ontology:its properties, the services it provides, and the parameters being used. These descriptions are broadcasted by each respective holon. On receiving such broadcast, holons will compose with each other if they meet the criteria for composition, for instance: if a holon H1 is requiring a service X, and it encounters another holon H2 that is providing such service, then H1 can initiate the composition procedure wit hH2.Once H1 gets composed wit hH2,it needs to update its definition to reflect its new state as a composed holon, i.e., a SoS,that is now providing serviceX.This update is carried out at run time through creating an instance of the holon concept(called,say,H3)to represent the new holon that has been encountered,and it also holds the definition of H2 in this case. Moreover,the ontology retains the ability to infer new knowledge based on the domain in formation provided.For example,there is a defined concept called composed Holon that is used to identify whether a holon is a simple or compose done. In this context,given that a holon has been composed to another holon, the ontology reasoner can determine whether this holon is a compose done.If H2 gets out of reach,then the ontology of the composed H1 will be updated to accommodate this change,simply by removing the H3 instance and clearing composed Holon.

# SOS Construction Model:
This section involves holonic ontologies to compose SOS runtime and in construction of SOS role of holonic ontologies.

# Composition Model:
Each holon needs to build a model that represents its awareness about the existence of other holons (i.e., systems) and their services.This model(called the compositio nmodel)is used to interact (compose)with the other systems by accessing their services.The composition model of a holon is represented as a weighted tree T rooted by the holon and with a depth of three. The children of the root are the holons that are directly reachable by the root holon. The leaf nodes represent the detected functionalities that are provided by or accessed through the children holons. Each leaf node i is assigned a weight that represents the cost of accessing the corresponding functionality Fi. For simplicity, in this paper we define the cost as the distance between the root and the holon providing Fi in terms of the number of intermediate holons.Other cost functions such as delay, reliability or aggregated Quality of Service(QoS)canals obe used. It is worth mentioning that a holon is not aware where a functionality Fi islocated.However,the holon is aware of the cost of accessing Fi and through which holon can Fi be accessed.
The compositio nmodel is frequently updated during the lifecycle of the holon.Updates include adding/ removing new holon branches, and updating the services of current ones. Adding and updating are performed upon receiving holon ontologies,while removing is carried out if the ontology is not received during a certain time period (we setthis to be three times the dissemination period)

# Reasoning architecture 
We assume that a system developer will create the atomic holon using the ontology. Once deployed,the holon lives in the described lifecycle. offers a high level view of the architecture that realizes SoS construction using the holonic approach.The architecture consists of five main components.

# OWL parser:
This component receives ontologies from surrounding holons and parses them,creating objects that represent each holon and its functionalities.We adopt OWL APIV5 to parse ontologies and extract the knowledge there in. displays an over view of the mapping of ontology elements to a holon object.For each Class element,a Java class is created to represent it.For example,a Java class Service represents the ontology Service concept, Profile represents the Profile concept,and soon.The Instance elements of the ontology are instances of the Class elements.The instances are linked together using DataType or Object properties.Such structure is mapped as attribute objects ofthe Holon object.For example,assume the ontology contains an element service i that is an element of class Service.This instance can be linked to the Holon concept using an object property element called has Service. In the Java Holon class,thisismappedby having an attribute called service_i of type Service in the Holon class. Finally, in the ontology Value elements represent some of the parameters values that are mapped as attribute values of the Holon Java objects. An example is the value‘25°C’of the Temperature element which is as signed to the temperature attribute in the Holon Java object.The OWL parser then passes the created Holon object to the Compiler. 

# Compiler:
This component formulates a notional model of the developing SoS as seen from the perspective of the receiving holon. This model takes the form of a treed at astructure with the receiving holon at the root,with each branch representing a neighboring holon and the functionalities provided either natively by it or indirectly through it. To constructor modify the tree,the Compiler creates a tree branch that represents the received holon object and its provided functiona lists as children.The cost of each functionality is also updated as this stage.After that,the newly formed branch is attached to the root holon as a child.The Compiler then passes the constructed tree to the Server/Mediator and OWL Renderer. 

# Server/Mediator:
This component receives requests for the functionalities provided by the system and serves them. It uses the constructed holon tree to specify whether the request can be satisfied by the system or needs to be directed to another holon. If the requested functionality is provided by the holon, then the systemp rocesses the request and responds to the requester. Otherwise,the system acts as a mediator and redirects the request to the holon that provides the request,waits for the response,and passes back the response to the requester. 

# OWL Renderer: 
What this component fundamentally does is represent the knowledge of a developing SoS based on interaction with new holons. 
The OWL Renderer reads the holon tree data structure from the Compiler and converts each node and the corresponding attributes into the appropriate XML tags that construct a valid ontology(i.e.,an inverse mapping. To render the ontology into an OWL description,we also use OWL API. Disseminator.Upon receiving an OWL description representing the holon and the compositions with other holons,the Disseminator publishes this description by broadcasting it–as is the policy in the Push strategy.

# Background and Challenegs:
Smart Home is an application of IoT that promises the ability for users to intelligently manage their homes with minimum intervention. Devices are utilized to monitor home conditions(e.g.,temperature,humidity)and the state of appliances(e.g.,battery levels)to enable smart management of energy consumption,security,and various house keeping functions.However,it is no longer realistic to assume a defined and small scale of smart home deployments. As smart home systems are increasing in popularity,the dimensionality of IoT devices used is increasing as new devices are constantly offered in the market and with increased capabilities. Thus, their deployment environments are continuelly evolving making self-adaptation a necessity. Furthermore,homogeneity cannot be taken for granted.The fact that these devices are developed by various vendors means that heterogeneous technologies and APIs exist.Smart home application developers need to learn these various technologies and APIs in order to develop IoT applications that manage the different aspects of a smart home in a coherent manner. Finally,IoT applications generally limit consumers to the pre determined deployment environments they were designed for. Consequently, they are brittle and susceptible to suboptimal operation when their context changes, e.g., due to a backhaul network fault or a server out age.Under such conditions,centralized (mainly cloud-based)approaches falls hort especially in network constrained conditions. Instead,IoT applications of ten need a way to be able to adapt at the edge without prepar at ionor central coordination.

# Experimental setup  
We developed a proof of concept prototype focused on smart home temperature management.We assume a smart home that has the We created a simple ontology for each of the devices .We also created an abstract work flow that aims at keeping the smart home temperature at 22°C,. The application reads the temperature from the thermometers. If the temperature is less than 22°C,it calls the heaters’s wit ch Heater On service to switch on the heating and the windows’close Windows to close the windows.If the temperature is higher than 22°C,it turns off the heater(calling switch Heater Off). If the temperature is higher than 22°Citals o opens the windows(by calling open Windows).

# Behaviour:
hows a The ontology shows that the controller provides services that are provided by the devices themselves in addition to services Selector, which selects concrete services for the abstract work flow. The execution starts with reading the temperature from the thermometer by calling the get Temeprature service.Table3 presents the experimental cases and the invoked cases for each case. As the table illustrates, the sequence of invoked services complies with theabstractworkflowprovidedbythedevelopertothecontroller, despite the developer not hard-coding the required connections between devices.For example,when the temperature is 22°C,the execution unit invokes the get Temperature, switch Heater Off, and close Windows services respectively,which complies with the abstract work flow. This case study demonstrates the potential for easing the development of IoT applications,where application developers donot need to know the details of smart device APIs.Definition of device ontologies (by vendors) and an abstract application work flow(by smart home developer)are sufficient for run time applications an the sis and execution by the proposed architecture.compares the tasks required from the smart home developers to implement this case study in both the classical and holonic approaches. 

# Background and challenges 
Inspired by heterogeneous fog clusters, we set a scenario where device interaction is constant. We use Apache Me sos,an orchestration tool commonly used to manage resources that are shared between different applications and their sub-tasks. In effect,Me sos enables the viewing of data centers and other computing clusters as a single consolidated resource. Although Me sos is a very useful utility,it was designed mainly for shared resources in relatively stable environments such as data centers. As such,the computing cluster can only change(i.e.,grow orshrink)through manual modifications to the configuration by the user. Me sos was not designed to work in an environment where node status is constant flux due to movement, unreliable power, or communication outages. These are typical challenges in fog computing. Me sos is also designed to work in a hierarchical fashion, whereby Agents (worker nodes) can only communicate directly to the Master but not through other Agents. 

# Overview of our approach 
Both of the above restrictions can be over come using the holonic ontology,which offers opportunistic composition(over coming the first restriction)and horizontal composition between self-describing clusters in the form of holons(second restriction).We draw a scenario here to demonstrate this using containers running over an un reliable infrastructure such as edge PoPs. In this scenario, each node can be a Master or an Agent. Following the basic design of Me sos,Masters are responsible for dispatching containers to the Agents,who in turn operate the containers. 

# Experimental setup 
As imple example is given here to illustrate how holons could be used to facilitate the union of Mesos clusters with mobile nodes without the need for establishing direct communication. Duetothe high mobility of nodes during the tests,the composition of SoSs is dynamic,creating several additions and removals of the Me sos Services. This is something that would have been prohibitive to accomplish using Me sos’manual configuration. We tested this use case study using 100 devices that can move freely. Every device is considered a node for Me sos and is individually defined as a holon at the beginning of the experiment. Shortly afterwards(aminutelater),bigger holons begin to be created,containing one or more devices. After that,each holon starts an internal processof randomized leaderel ection to elect a master from amongs t the constituent devices. Each holon contains parameters to define its identifier,mobility, and whether or not it is a Me sos Master. Additionally, each holon contains three services: Ask For Master is performed everytime two holons reach each other for the first time,where it would return the ID of the Master. After a holon receives the request of whom is its Master, it will perform the Send Master service to send such ID. Bridge To Master isused by the nodes to communicate with the Master through its Agents. 

# Behavior 
Fig.14 a presents the starting point with holons H1 and H2. H1 is formed of four nodes: nodeA,working as a Master,while nodeB, node C and node D as Agents. On the other hand,H2 is formed of two nodes:nodeF,a Master,and node E,an Agent. In this case,H1 and H2 cannot reach each other. As node C and node E come in range of one another they are triggered to exchange ontologies and call Ask For Master and sub sequently Send Master. The orange arrow in the figure represents this interaction. Then,node C and node E broadcast their new ontologies to neighbors . Now, H1 and H2 are not just in contact with each other,they are part of a news uper-holon H3,which is the union of H1 and H2 as all their nodes receive the updated ontology and adopt it as their new ontology. All Agents are sharing the Masters node A(from H1)and node F (from H2). This is achieved using the service Bridge To Master,performed continuously by node C and node E while they can reach each other.The resulting SoS H3 has 2 Master nodes and 4 Agents. Therefore,each of the two Masters can communicate to all Agents in H3 as if they were connected directly. Similarly,this approach is also able to deal with Master  mobility as long as the basic structure of a Me sos cluster is not broken down. As such,the ontological exchange and reasoning of holons allows Apache Me sos to transcend its innatedesig n short comings and enables it to form a dynamic cluster structure. Achieving such structure throug h manual configuration(which is the only way possible using native Mesos)significantly restrict sad aptation and reduces cluster efficiency by a factor of 5 compared to using holons.Table 5 compares the tasks required from Mesos developers to implement this cases tudy in both the classical and proposed approaches. 

# Simulations 
For evaluating the efficacy of automated expansion of Mesos clusters through the use of holon ontologies, we used the Omnet++ discrete-events imulation framework to simulate 100 nodes. We set the node transmission range to 20m and theirs peed to 1.43m/s, an average walking speed. Additionally, the nodes used the individual-level(random walks)as a mobility model. We used Mesosaurus to create task loads to test the performance of the formed clusters. Specifically,we seek the length of time required by a Mesos Master to perform a specific task. The task created for this experiment is one that a Master with 5A gents will normally perform in about 20 seconds. If more Agents are employed,execution time is expected to decrease. plots the average task execution time across all Mesos clusters after 20 experiment runs.Using Mesos’native cluster management method,task execution time decreases slightly(from≈23s) as Masters expand their clusters through the use of scripts that add nodes they encounter in their environment. This improvement in performance, however, eventually plateaus (≈ 20s) as churn overwhel ms Masters through frequent configuration management, despite the use of automated scripts. On the other hand, using holons introduces some overhead in terms of ontology creation and reasoning.This results in a slightly in flated initial executiont ime (≈27s). However,as nodes encounter others during the life time of the simulation,Mesos clusters identifying as holons expand dynamically according to changes in their environment. Compiling and reasoning overheads soon become relatively in significant,enabling Mesos holons to achieve an average of 17s execution time,a15% improvement in performance.

# Discussion of Case Studies: 
The above experiments show how we are able to automatically self discover and compose systems through rich ontological description of elementary systems that are required to realizea SoS. We now reflect on there search questions we formulated.

# Abstractions for SoS representation: 
Holons offer the ability for systems to richly describe themselves, and independently reason about the change in their environment and how it might affect their set up and operation.This concept enables systems to reflecton their existence and how they fit into what is around them.This in line with theeth o s of reflective middle ware, which enables systems to build a representation of it self that it can then adapt. In addition,holonic representation allows systems to transfer such knowledge about themselves to other systems they get in touch with. Along with this,each system is able to build are presentation of the behavior of systems in its vicinity and form more complex systems without prior arrangement.
There is an assumption that each system needs to start with a representation of it self in its simplest form as anontology.Because of this,we built our ontological architecture on the most generalize and easy-to-use ontology available in the literature.Further more, using such frame work makes it easy to create ontologies,which is a relatively small development overhead of similar or less scale of defining a system’sAPI. However,this enables the system to adapt after its deployment and unlock a new world of complex system creation that facilitates new forms of context- aware applications. 

# Techniques for SoS composition: 
The presented case studies demonstrated how a developer could define desired behavior at a high level( summarized in Tables 4– 5),and a system is subsequently composed of other sub-systems to align with this behavior. Our architecture allows systems to independently reason about their environment,and how changes might affect their setup and operation. This is a powerful concept as it maintains the separation of concerns, which is crucial for effective system development,whilst also reaping the rewards of complex system formation through autonomous composition. Further more,the holonic ontology could be applied at different levels: at the atomic service level (e.g., temperature sensor), at a system component level(e.g.,smartsensors),or at a higher system level(e.g.,smart home controller). This enables developers to write behavior at different levels of granularity with the same modeling effort,which is especially beneficial for dynamic environments such as the IoT where context-dependent behavior could be sought at different levels. 

# SoS adaptation:  
The presented architecture exploits the holonic ontology and maintains the holonic life cycle to fully support the vision of autonomous SoS composition and adaptation presented in this paper.The architecture continuously updates the holonic ontology allowing up-to date SoS state exchange and enables timely response to changes. This allows holons to detect failures and discover new functionalities a holon needs to re build a SoS.Asdemonstratedinthecluster managementcasestudy(§8),adaptation is fully autonomous. The system can,for example,detect the arrival of newworking nodes and add them to the cluster. Furthermore,human involvementis only needed when major requirements changes are required,i.e.,at the SoS level. For example, a change in the smart home requirements that demands the deployment of new devices might require updating the behavior of the smart homea pplications,i.e.,developers need to adaptthe abstract work flows. However,such intervention is guaranteed to be minimal as developers donot need to know the low-level details of post-deployment systems such as device-specific APIs. Therefore,our proposed architecture provides a generic frame workfor supporting high-level behavior adaptation to real implementation.

# Quantative Evolution: 
As mentioned,our proposed framework includes means of parsing holon ontologies to build a tree that represents SoS construction, and subsequently rendering the tree to disseminate the modified ontologies that reflect SoS evolution. We conducted experiments to evaluate the feasibility and correctness of this approach. Specifically, we investigate the time required to parse and render the ontologies at different scales,and we assess the validity of these stages. From this, we extract conclusions about the ability of using holons to compose SoS during runtime and at scale. The platform used in the experiments is Intel Corei7 with 16 GB RAM,runningLinux Ubuntu16.04 and Java SEv1.8.0.Results shown are theme an values from 100 experiment repetitions.

# Parsing: 
This first experiment focuses on evaluating the parsing time defined as the time of converting a received ontology into a tree.Recall that the tree contains the holon object as a root and the services provided by/via it as children. So,we vary the number of children (i.e.,services)as the main dimension affecting parsing scalability. We observe that parsing time increases linearly with the number of services,amounting to < 0.35s for a very complex SoS that provides 1,000 services either directly or indirectly. We find this level of complexity to be acceptable, as it indicates the feasibility of parsing an increasing number of holons in a SoS.

# Rendering: 
We now evaluate the rendering time defined as the time to convert a holon tree into an ontology to be disseminated. We vary both the number of neighbor holons(children)and the number of their services(leaves) demonstrates that the rendering overhead increases both with the number of holons and the number of services per holon. This is acceptable for SoSs with up to 100 servicesperholon,where rendering over head is≈ 5s. However this quickly in flates for holons with 1,000 or more sub-systems,where it could take up to a minute to create an ontology that could be used for composition.

# Validation In this sub section:
we validate the output of the parsing and rendering operations using tw oexperiments. In the first experiment we adopt the process depicted. We create ontologies for 100 holons with random values for each of their parameter and service values. We then pass the ontology files to the OWL Parser,which creates the holon trees. The trees are then passed to the OWL Renderer to render them in to ontologies. We then query(using OWL API)both the created ontologies and the rendere dones to check if the results are equivalent. For al l100 ontologies,there turned values were indeed equivalent. In the second experiment, we adopt the process portrayed. Here,we synthesized 100 compiled trees,each representing a SoS.We then passed the trees to the OWL Renderer to render them into a SoS ontology for each tree.Then we queried both the rendered ontologies and the created trees to compare the results. Again,for all of the 100 cases,there turned values were equal.

# Conclusion:
We propose an approach for the dynamic construction of distributed systems of systems(SoSs). The approach is based on two key ideas. First, we define the concept of a holon as a self-describing system, which could span from atomic to complex distributed systems. Holons need to be prepared for autonomic integration with other holons. This is achieved by comprehensively describing them using an ontology that enables both self-awareness and context awareness. Second,an architecture for SoS construction is proposed to make use of the holon description to discover,reason about their functionalities,and integrate them to form more complex SoS. We demonstrate the feasibility of our approach through two case studies that implement contrasting SoS construction scenarios. The cases studies show that our approach reduces the development complexity of SoS by abstracting system heterogeneity using holon descriptions and their autonomic manipulation at run time. We also evaluates calability and validity through experimentation,concluding that our approach is realistically feasible with performance exhibiting a linear trend for manipulating and reasoning about descriptions. This novel contribution has strong potential to be applied in various application fields beyond those covered in our case studies. Similarly,our architecture could be modified to caterfor domain specific interactions if particular situational-awareness are needed. Moreover,we are extending this work by building tools that allow very high levels pecification of desired SoS construction behavior and evolution.

     







 





























